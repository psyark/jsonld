package codegen

import (
	"sort"
	"strings"

	"github.com/dave/jennifer/jen"
)

type Builder struct {
	classMap map[string]*Class
}

func NewBuilder(d Document) *Builder {
	b := &Builder{
		classMap: map[string]*Class{},
	}
	for _, g := range d.Graph {
		if g.HasType("rdfs:Class") {
			// クラス作成
			c := b.getClass(g.ID)
			c.Name = g.GetGoID()
			c.Comment = g.Comment
			c.isDataType = g.HasType("schema:DataType") || c.Name == "DataType"

			// 親クラスを設定
			for _, ref := range g.SubClassOf {
				if ref.ID != "rdfs:Class" {
					c.Parents = append(c.Parents, b.getClass(ref.ID))
				}
			}
		}
	}
	for _, g := range d.Graph {
		if g.HasType("rdf:Property") {
			p := &Property{Name: strings.TrimPrefix(g.ID, "schema:"), Comment: g.Comment}
			for _, ref := range g.DomainIncludes {
				c := b.getClass(ref.ID)
				// このプロパティをクラスメンバーに追加
				c.Members = append(c.Members, p)
			}
		}
	}

	return b
}

func (b *Builder) getClass(id string) *Class {
	if _, ok := b.classMap[id]; !ok {
		b.classMap[id] = newClass()
	}
	return b.classMap[id]
}

func (b *Builder) Build() error {
	if err := b.buildClasses(); err != nil {
		return err
	}

	return nil
}

func (b *Builder) buildClasses() error {
	classGo := jen.NewFile("jsonld")
	classGo.Comment("Code generated by jsonld.codegen; DO NOT EDIT.").Line()

	classNames := []string{}
	for k := range b.classMap {
		classNames = append(classNames, k)
	}
	sort.Strings(classNames)

	cases := jen.Statement{}
	for _, k := range classNames {
		c := b.classMap[k]
		if !c.IsDataType() {
			code := jen.Case(jen.Lit(c.Name)).Return().Op("&").Id(c.Name).Block()
			cases.Add(code)
		}
	}
	classGo.Func().Id("NewThing").Call(jen.Id("name").String()).Interface().Block(
		jen.Switch(jen.Id("name")).Block(cases...),
		jen.Panic(jen.Id("name")),
	)

	for _, k := range classNames {
		classGo.Add(b.classMap[k].Code())
	}

	return classGo.Save("../gen_classes.go")
}
